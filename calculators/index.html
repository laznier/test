<!DOCTYPE html>
<html>
<head>
  <title>Advanced Stock Price Prediction Tool</title>
  <!-- Include Plotly for interactive charts -->
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif; 
      margin: 20px;
    }
    .container {
      max-width: 900px;
      margin: auto;
    }
    label {
      display: block;
      margin-top: 10px;
    }
    input, select, button {
      padding: 5px;
      margin-top: 5px;
    }
    #result {
      margin-top: 20px;
    }
    #explanation {
      margin-top: 20px; 
      padding: 10px; 
      border: 1px solid #ccc;
      background-color: #f9f9f9;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Advanced Stock Price Prediction Tool</h1>
    <p>
      Enter a ticker symbol (e.g., AAPL), the historical period (in months) to consider, select a future date, and choose a forecasting method.
      The tool uses advanced techniques to predict the future stock price and then generates an explanation of the methods and math used.
    </p>
    
    <label for="ticker">Ticker Symbol (e.g., AAPL):</label>
    <input type="text" id="ticker" value="AAPL">
    
    <label for="period">Historical Period (in months):</label>
    <input type="number" id="period" value="12" min="1">
    
    <label for="futureDate">Future Date:</label>
    <input type="date" id="futureDate">
    
    <label for="forecastMethod">Forecast Method:</label>
    <select id="forecastMethod">
      <option value="mc">Monte Carlo Simulation (GBM)</option>
      <option value="lr">Linear Trend Forecast</option>
      <option value="ensemble">Ensemble Forecast (Average of MC &amp; LR)</option>
    </select>
    
    <button id="simulateButton">Run Simulation</button>
    <div id="loading" style="display:none;">Loading data and running simulation...</div>
    
    <div id="result">
      <div id="chart" style="width:100%;height:400px;"></div>
      <!-- Slider for Monte Carlo histogram (if applicable) -->
      <div id="sliderDiv" style="display:none;">
        <label for="priceSlider">Select Price Threshold:</label>
        <input type="range" id="priceSlider" min="0" max="1000" step="1" value="0">
        <span id="thresholdValue">0</span>
        <p>Probability of final price above threshold: <span id="probability">0%</span></p>
      </div>
    </div>
    
    <div id="explanation"></div>
  </div>
  
  <script>
    // Utility: Generate a standard normal random variable (Box-Muller Transform)
    function randn_bm() {
      let u = 0, v = 0;
      while(u === 0) u = Math.random();
      while(v === 0) v = Math.random();
      return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
    }

    // Fetch historical stock data from Alpha Vantage
    async function fetchHistoricalData(ticker) {
      const apiKey = 'A90O2RABGD56MHE6';
      const url = `https://www.alphavantage.co/query?function=TIME_SERIES_DAILY&symbol=${ticker}&outputsize=full&apikey=${apiKey}`;
      const response = await fetch(url);
      const data = await response.json();
      if(data["Error Message"] || !data["Time Series (Daily)"]) {
        throw new Error("Error fetching data. Check ticker symbol or API key.");
      }
      return data["Time Series (Daily)"];
    }

    // Process historical data to extract prices within the desired period
    function processHistoricalData(timeSeries, periodMonths) {
      const dates = Object.keys(timeSeries).sort((a, b) => new Date(a) - new Date(b));
      const endDate = new Date(dates[dates.length - 1]);
      const startDate = new Date(endDate);
      startDate.setMonth(startDate.getMonth() - periodMonths);
      
      let prices = [];
      for(let date of dates) {
        const currentDate = new Date(date);
        if(currentDate >= startDate && currentDate <= endDate) {
          prices.push({
            date: currentDate,
            close: parseFloat(timeSeries[date]["4. close"])
          });
        }
      }
      // Ensure ascending order
      prices.sort((a, b) => a.date - b.date);
      return prices;
    }

    // Compute log returns and derive parameters for Monte Carlo simulation
    function computeStats(prices) {
      let logReturns = [];
      for(let i = 1; i < prices.length; i++) {
        const prev = prices[i-1].close;
        const curr = prices[i].close;
        logReturns.push(Math.log(curr / prev));
      }
      const mean = logReturns.reduce((a, b) => a + b, 0) / logReturns.length;
      const variance = logReturns.reduce((sum, r) => sum + Math.pow(r - mean, 2), 0) / (logReturns.length - 1);
      const stdDev = Math.sqrt(variance);
      return { mean, stdDev, lastPrice: prices[prices.length-1].close };
    }

    // Run Monte Carlo simulation using GBM
    function runSimulation(lastPrice, mean, stdDev, T, numSimulations = 10000) {
      let finalPrices = [];
      for(let i = 0; i < numSimulations; i++){
        const Z = randn_bm();
        const ST = lastPrice * Math.exp((mean - 0.5 * stdDev * stdDev) * T + stdDev * Math.sqrt(T) * Z);
        finalPrices.push(ST);
      }
      return finalPrices;
    }

    // Linear regression forecast using least squares method
    function linearRegressionForecast(prices, futureDate) {
      // x = days since first date
      const firstDate = prices[0].date;
      let xs = prices.map(p => (p.date - firstDate) / (1000 * 60 * 60 * 24)); // in days
      let ys = prices.map(p => p.close);
      const n = xs.length;
      const sumX = xs.reduce((a, b) => a + b, 0);
      const sumY = ys.reduce((a, b) => a + b, 0);
      const sumXY = xs.reduce((sum, x, i) => sum + x * ys[i], 0);
      const sumX2 = xs.reduce((sum, x) => sum + x * x, 0);
      const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
      const intercept = (sumY - slope * sumX) / n;
      const futureX = (futureDate - firstDate) / (1000 * 60 * 60 * 24);
      const forecastPrice = intercept + slope * futureX;
      return { forecastPrice, slope, intercept };
    }

    // Update chart for Monte Carlo simulation (histogram with slider)
    function updateChartMC(finalPrices) {
      const trace = {
        x: finalPrices,
        type: 'histogram',
        marker: { color: '#7f7f7f' }
      };

      const layout = {
        title: 'Simulated Final Stock Prices Distribution (Monte Carlo - GBM)',
        xaxis: { title: 'Price' },
        yaxis: { title: 'Frequency' }
      };

      Plotly.newPlot('chart', [trace], layout);

      // Show slider section
      document.getElementById('sliderDiv').style.display = 'block';
      const minPrice = Math.floor(Math.min(...finalPrices));
      const maxPrice = Math.ceil(Math.max(...finalPrices));
      const slider = document.getElementById('priceSlider');
      slider.min = minPrice;
      slider.max = maxPrice;
      slider.value = minPrice;
      document.getElementById('thresholdValue').innerText = minPrice;
      updateProbability(finalPrices, minPrice);
      slider.oninput = function() {
        const threshold = parseFloat(this.value);
        document.getElementById('thresholdValue').innerText = threshold;
        updateProbability(finalPrices, threshold);
      };
    }

    function updateProbability(finalPrices, threshold) {
      const count = finalPrices.filter(price => price >= threshold).length;
      const probability = (count / finalPrices.length * 100).toFixed(2);
      document.getElementById('probability').innerText = probability + '%';
    }

    // Update chart for Linear Trend Forecast (line chart)
    function updateChartLinear(prices, futureDate, forecastPrice) {
      let trace1 = {
        x: prices.map(p => p.date),
        y: prices.map(p => p.close),
        mode: 'lines+markers',
        name: 'Historical Prices'
      };
      let lastDate = prices[prices.length - 1].date;
      let trace2 = {
        x: [lastDate, futureDate],
        y: [prices[prices.length - 1].close, forecastPrice],
        mode: 'lines+markers',
        name: 'Linear Trend Forecast'
      };
      let layout = {
        title: 'Linear Trend Forecast',
        xaxis: { title: 'Date' },
        yaxis: { title: 'Price' }
      };
      Plotly.newPlot('chart', [trace1, trace2], layout);
      // Hide slider for non-histogram methods
      document.getElementById('sliderDiv').style.display = 'none';
    }

    // Update chart for Ensemble Forecast: use MC histogram with vertical markers for LR and ensemble values
    function updateChartEnsemble(finalPrices, lrForecast, ensembleForecast) {
      const trace = {
        x: finalPrices,
        type: 'histogram',
        marker: { color: '#7f7f7f' },
        name: 'Monte Carlo Simulation'
      };
      const layout = {
        title: 'Ensemble Forecast (Monte Carlo Histogram with LR & Ensemble Markers)',
        xaxis: { title: 'Price' },
        yaxis: { title: 'Frequency' },
        shapes: [
          {
            type: 'line',
            x0: lrForecast,
            y0: 0,
            x1: lrForecast,
            y1: Math.max(...finalPrices),
            line: { color: 'red', dash: 'dash' }
          },
          {
            type: 'line',
            x0: ensembleForecast,
            y0: 0,
            x1: ensembleForecast,
            y1: Math.max(...finalPrices),
            line: { color: 'blue', dash: 'dot' }
          }
        ]
      };
      Plotly.newPlot('chart', [trace], layout);
      // Show slider section
      document.getElementById('sliderDiv').style.display = 'block';
      const minPrice = Math.floor(Math.min(...finalPrices));
      const maxPrice = Math.ceil(Math.max(...finalPrices));
      const slider = document.getElementById('priceSlider');
      slider.min = minPrice;
      slider.max = maxPrice;
      slider.value = minPrice;
      document.getElementById('thresholdValue').innerText = minPrice;
      updateProbability(finalPrices, minPrice);
      slider.oninput = function() {
        const threshold = parseFloat(this.value);
        document.getElementById('thresholdValue').innerText = threshold;
        updateProbability(finalPrices, threshold);
      };
    }

    // Generate explanation text based on the chosen method and computed forecasts
    function generateExplanation(method, mcStats, lrResult, ensembleForecast) {
      let explanation = "<h3>Explanation of Results</h3>";
      explanation += "<p><strong>Data Source:</strong> Historical stock data is sourced from the Alpha Vantage API.</p>";
      if(method === "mc") {
        explanation += "<p><strong>Method:</strong> Monte Carlo Simulation using Geometric Brownian Motion (GBM).</p>";
        explanation += "<p>The simulation uses the formula:</p>";
        explanation += "<p style='font-style: italic;'>S<sub>T</sub> = S<sub>0</sub> × exp((μ - 0.5σ²)T + σ√T × Z)</p>";
        explanation += "<p>S<sub>0</sub> is the last observed price, μ is the mean of log returns, σ is the standard deviation, T is the time horizon (in years), and Z is a standard normal random variable.</p>";
      } else if(method === "lr") {
        explanation += "<p><strong>Method:</strong> Linear Trend Forecast using least squares regression.</p>";
        explanation += "<p>This method fits a line to the historical prices using the formula:</p>";
        explanation += "<p style='font-style: italic;'>Price = intercept + slope × (time in days)</p>";
        explanation += "<p>The line is then extrapolated to the selected future date.</p>";
      } else if(method === "ensemble") {
        explanation += "<p><strong>Method:</strong> Ensemble Forecast combining Monte Carlo Simulation (GBM) and Linear Trend Forecast.</p>";
        explanation += "<p>The ensemble forecast is computed as the average of the Monte Carlo forecast (using the mean of simulated prices) and the linear regression forecast.</p>";
      }
      if(lrResult) {
        explanation += `<p><strong>Linear Regression Details:</strong> Slope = ${lrResult.slope.toFixed(4)}, Intercept = ${lrResult.intercept.toFixed(4)}, Forecast Price = ${lrResult.forecastPrice.toFixed(2)}</p>`;
      }
      if(mcStats) {
        explanation += `<p><strong>Monte Carlo Simulation Details:</strong> Last Price = ${mcStats.lastPrice.toFixed(2)}, Mean Log Return = ${mcStats.mean.toFixed(4)}, Standard Deviation = ${mcStats.stdDev.toFixed(4)}</p>`;
      }
      if(method === "ensemble" && ensembleForecast) {
        explanation += `<p><strong>Ensemble Forecast Price:</strong> ${ensembleForecast.toFixed(2)}</p>`;
      }
      document.getElementById('explanation').innerHTML = explanation;
    }

    // Main simulation event
    document.getElementById('simulateButton').addEventListener('click', async () => {
      document.getElementById('loading').style.display = 'block';
      const ticker = document.getElementById('ticker').value.trim();
      const periodMonths = parseInt(document.getElementById('period').value);
      const futureDateInput = document.getElementById('futureDate').value;
      const forecastMethod = document.getElementById('forecastMethod').value; // "mc", "lr", or "ensemble"
      
      if(!ticker || !futureDateInput) {
        alert("Please enter both a ticker symbol and a future date.");
        document.getElementById('loading').style.display = 'none';
        return;
      }
      
      try {
        const timeSeries = await fetchHistoricalData(ticker);
        const prices = processHistoricalData(timeSeries, periodMonths);
        if(prices.length < 2) {
          alert("Not enough historical data available for the specified period.");
          document.getElementById('loading').style.display = 'none';
          return;
        }
        
        // Convert future date input to a Date object
        const futureDate = new Date(futureDateInput);
        // Compute linear regression forecast
        const lrResult = linearRegressionForecast(prices, futureDate);
        
        let mcStats = null;
        let finalPrices = null;
        let ensembleForecast = null;
        
        if(forecastMethod === "mc" || forecastMethod === "ensemble") {
          // Compute parameters for Monte Carlo simulation
          mcStats = computeStats(prices);
          // Compute time horizon (T in years) from the last historical date to the future date
          const lastDate = prices[prices.length - 1].date;
          const diffTime = Math.abs(futureDate - lastDate);
          const T = diffTime / (365 * 24 * 60 * 60 * 1000);
          finalPrices = runSimulation(mcStats.lastPrice, mcStats.mean, mcStats.stdDev, T);
        }
        
        if(forecastMethod === "mc") {
          updateChartMC(finalPrices);
          generateExplanation("mc", mcStats, lrResult, null);
        } else if(forecastMethod === "lr") {
          updateChartLinear(prices, futureDate, lrResult.forecastPrice);
          generateExplanation("lr", null, lrResult, null);
        } else if(forecastMethod === "ensemble") {
          // Ensemble forecast: average of MC mean and linear regression forecast
          const mcMean = finalPrices.reduce((a, b) => a + b, 0) / finalPrices.length;
          ensembleForecast = (mcMean + lrResult.forecastPrice) / 2;
          updateChartEnsemble(finalPrices, lrResult.forecastPrice, ensembleForecast);
          generateExplanation("ensemble", mcStats, lrResult, ensembleForecast);
        }
      } catch (error) {
        alert("Error: " + error.message);
      }
      document.getElementById('loading').style.display = 'none';
    });
  </script>
</body>
</html>
